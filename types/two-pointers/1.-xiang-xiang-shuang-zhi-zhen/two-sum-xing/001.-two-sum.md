# ğŸŸ¢ 001. Two Sum

å…¶ä»–æ–¹æ³•: HashMap

<details>

<summary>é¢˜ç›®æè¿°</summary>

Given an array of integers <mark style="color:blue;">`nums`</mark> and an integer <mark style="color:orange;">`target`</mark>, return _<mark style="color:orange;">**indices**</mark> of the two numbers such that they add up to `target`_.

You may assume that each input would have _<mark style="color:orange;">**exactly**</mark>_<mark style="color:orange;">** **</mark><mark style="color:orange;">**one solution**</mark><mark style="color:orange;">,</mark> and you may not use the _same_ element twice.

You can return the answer in any order.

&#x20;

**Example 1:**

<pre><code><strong>Input: nums = [2,7,11,15], target = 9
</strong><strong>Output: [0,1]
</strong><strong>Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
</strong></code></pre>

</details>

<details>

<summary>è§£é¢˜æ€è·¯</summary>

<mark style="background-color:orange;">**Preparation**</mark>

* &#x20;**å»ºç«‹ **<mark style="color:red;">**helper class**</mark>** : pair**&#x20;
  * å› ä¸ºæœ€ç»ˆè¦returnçš„æ˜¯ index, not value => æ‰€ä»¥hash/å»ºpair
  * è®°å¾—è¦implement comparableå› ä¸ºè¦sortä¹‹åçš„ pair array
* &#x20;**Iterate initial array to form an Pair Array => sort**

<mark style="background-color:orange;">**Two Pointersçš„ä½“ç°**</mark>

1. left & right pointers are the index 0 & n-1
2. retrieve the value of the corresponding index to get the SUM
3. ä¸¤ä¸ªpointers å¯¹æ’ç›¸å‘ç§»åŠ¨ SUM å’Œ TARGET ä½œæ¯”è¾ƒ
   1. å¦‚æœtarget == sum => return the index
   2. å¦‚æœtarget > sum =>  left pointeré€’å¢
   3. å¦‚æœtarget < sum => right pointeré€’å¢

</details>

<details>

<summary>Code Demo</summary>

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // S1: populate the array to Pair objects
        int n = nums.length;
        Pair[] pairs = new Pair[n];
        
        for (int i = 0; i < n; i++) {
            pairs[i] = new Pair(i, nums[i]);  // ---- O(n)
        }
        // S2: sort the pairs array 
        Arrays.sort(pairs);                   // ---- O(nlogn)
        
        // S3: Two Pointers
        int left = 0;
        int right = n - 1;
        
        for (int i = 0; i < nums.length; i++) { // worst case: ---- O(n)

            int sum = pairs[left].value + pairs[right].value;

            if (sum == target) {
                return new int[]{pairs[left].index, pairs[right].index};
            } else if ( sum < target) {
                left ++;
            } else {
                right--;
            }
        }
        return null;
    }

    static class Pair implements Comparable<Pair> {
        int value;
        int index;

        Pair(int index, int value) {
            this.value = value;
            this.index = index;
        }

        public int compareTo(Pair anotherPair) {
            // need to return
            return Integer.compare(this.value, anotherPair.value);
        }

    }
}
```

</details>

<details>

<summary>Code Analysis</summary>

Time Complexity:&#x20;

* The dominant factor in the time complexity is the <mark style="color:yellow;">**sorting step**</mark>, which takes <mark style="color:yellow;">O(nlogn)</mark> time complexity due to the use of the Arrays.sort() method.&#x20;
* The rest of the operations in the function, including the two-pointers traversal, are linear, contributing O(n) to the time complexity.&#x20;
* Therefore, the overall time complexity is <mark style="color:red;">**O(n log n)**</mark> due to the sorting.

Space Complexity:&#x20;

* The space complexity is determined by the additional space used to create the pairs array of Pair objects.
* &#x20;This array requires O(n) space, where n is the number of elements in the nums array.&#x20;
* The rest of the memory usage is relatively constant, with no significant increase as the input size grows. Therefore, the overall space complexity is O(n).

</details>

<details>

<summary> Key Points</summary>

1. è¾…åŠ©class <mark style="background-color:blue;">`static class Pair implements Comparable<Pair>`</mark>

* The <mark style="color:yellow;">**compareTo method**</mark> compares the values of two Pair objects and returns a negative value if the current object's value is less than the other object's value, a positive value if it's greater, and zero if they are equal. This comparison logic is essential for sorting the array of Pair objects.
* When we use Arrays.sort(pairs) to sort the array of Pair objects, the sorting algorithm uses the compareTo method to determine the order of the objects. This is why the compareTo method is crucial in defining how the objects should be sorted.

2. Arrayçš„å»ºç«‹  Pair\[] pairs = new Pair\[n];  pass in the element number

</details>



