---
description: Summary of methods
---

# Data Structure

> When solving LeetCode problems, we'll often encounter a variety of data structures and algorithms. Here are some commonly used methods, techniques, and data structures that are useful for tackling different types of problems on the platform:



String Methods: String Length: String.length() Character Access: String.charAt() Substring: String.substring() Concatenation: String.concat() String Replacement: String.replace() String Splitting: String.split() Case Conversion: String.toUpperCase() / String.toLowerCase() String Searching: String.indexOf() String Comparison: String.equals() / String.equalsIgnoreCase()

Hash Map: HashMap for efficient key-value pair storage and retrieval. containsKey(), get(), put(), remove(), keySet(), etc.

Two-Pointers: left and right pointers for traversing arrays or strings. Used for problems involving searching, finding pairs, or specific conditions.

DFS (Depth-First Search) and BFS (Breadth-First Search): Techniques for exploring graphs and trees. DFS: Recursive approach to explore deeper nodes first. BFS: Queue-based approach to explore nodes level by level. Recursion:

Divide and conquer strategy for solving problems. Often used in tree, graph, and combinatorial problems.

Backtracking: Exploring all possible solutions and discarding ones that do not meet the criteria. Common in problems involving permutations, subsets, and combinations.

Sliding Window: Efficient technique for finding a subarray or substring with specific properties. Useful for problems with contiguous elements, such as maximum/minimum sum subarray.

Greedy Algorithms: Making locally optimal choices to achieve a global optimum. Often used in optimization problems where there's a clear "best" choice at each step.

Dynamic Programming: Solving problems by breaking them down into smaller subproblems and storing their solutions. Techniques include memoization (top-down) and tabulation (bottom-up).
