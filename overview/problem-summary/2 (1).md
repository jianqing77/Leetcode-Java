# ğŸŸ¢ 0543 - Diameter of Binary Tree

<details>

<summary>Description é¢˜ç›®æè¿° </summary>

Given the `root` of a binary tree, return _the <mark style="color:yellow;">**length of the diameter**</mark> of the tree_.

The **diameter** of a binary tree is the <mark style="color:green;">**length of the LONGEST path between any two nodes in a tree**</mark>. This path <mark style="color:red;">**may or may not pass through the**</mark><mark style="color:red;">** **</mark><mark style="color:red;">**`root`**</mark><mark style="color:red;">**.**</mark>

The <mark style="color:yellow;">**length**</mark> of a path between two nodes is represented by the number of <mark style="color:yellow;">**edges**</mark> between them.

<pre><code>       1
     /   \
    2      3      
   / \    / \
<strong>  4   5   6   7
</strong><strong> /     \  
</strong><strong>8       9
</strong><strong>         \
</strong><strong>          10
</strong><strong>            \
</strong><strong>            11
</strong></code></pre>

<pre><code><strong>Input: root = [1,2,3,4,5]
</strong><strong>Output: 3
</strong><strong>Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
</strong></code></pre>

<pre><code><strong>Input: root = [1,2]
</strong><strong>Output: 1
</strong></code></pre>

**Constraints:**

* The number of nodes in the tree is in the range `[1, 104]`.
* `-100 <= Node.val <= 100`

</details>

<details>

<summary>è§£é¢˜æ€è·¯ Intuition </summary>

### é¢˜ç›®å¤§æ„

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

### è§£é¢˜æ€è·¯

* åˆšå¼€å§‹æ²¡æ€è·¯ï¼šlength = nodes - 1
*   <mark style="background-color:orange;">maxDepth of left + maxDepth of right??</mark> âœ…



    ä½ çš„è§£é¢˜æ€è·¯æ˜¯æ­£ç¡®çš„ã€‚

    * äºŒå‰æ ‘çš„diameterç›´å¾„å¯ä»¥ç”±left subtree maxDepth + right subtreeçš„max depthè·å¾—ã€‚
    * ä¸€èˆ¬å°è±¡ä¸­ï¼ŒäºŒå‰æ ‘çš„diameterå°±æ˜¯é€šè¿‡rootçš„æœ€é•¿è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„å¿…å®šæ˜¯å·¦å­æ ‘çš„ä¸€æ¡æœ€é•¿è·¯å¾„ç»è¿‡æ ¹èŠ‚ç‚¹åˆ°å³å­æ ‘çš„ä¸€æ¡æœ€é•¿è·¯å¾„ã€‚å¯æ˜¯é¢˜ç›®è¦æ±‚ï¼šmax diameterä¸ä¸€å®šç»è¿‡root.åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬**éœ€è¦**<mark style="color:yellow;">**åœ¨æ¯ä¸ªnodeå¤„éƒ½è®¡ç®—ä¸€æ¬¡diameter**</mark>**,** ç„¶åå–<mark style="color:yellow;">**æœ€å¤§å€¼**</mark>ã€‚ç›´å¾„å°±æ˜¯å·¦å­æ ‘çš„æœ€å¤§æ·±åº¦åŠ ä¸Šå³å­æ ‘çš„æœ€å¤§æ·±åº¦ã€‚ç„¶åæˆ‘ä»¬è¿”å›å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ï¼Œè¿™æ ·ä¸Šå±‚èŠ‚ç‚¹å°±å¯ä»¥è®¡ç®—å®ƒä»¬çš„ç›´å¾„ã€‚
    * å…¶ä»–
      * å®ç°è¿™ä¸ªæ€è·¯ï¼Œä½ éœ€è¦ä¸€ä¸ª<mark style="color:yellow;">**helper function**</mark>æ¥è®¡ç®—äºŒå‰æ ‘çš„<mark style="color:yellow;">**max Depthã€‚**</mark>
      * åŒæ—¶ï¼Œä½ éœ€è¦ä¸€ä¸ª<mark style="color:yellow;">**global variable(maxDiameter**</mark>)æ¥è®°å½•å½“å‰å·²çŸ¥çš„æœ€å¤§ç›´å¾„ã€‚åœ¨è®¡ç®—æœ€å¤§æ·±åº¦çš„è¿‡ç¨‹ä¸­ï¼Œä½ å¯ä»¥updateè¿™ä¸ªå…¨å±€å˜é‡ã€‚

</details>

<details>

<summary>Algorithm </summary>

1. initiate <mark style="color:blue;">**global variable**</mark> <mark style="color:yellow;">**maxDiameter = 0**</mark>ã€‚\
   \=> store current max diameter -> <mark style="color:red;">**to be updatedã€‚**</mark>
2. Define a <mark style="color:blue;">**helper function**</mark> <mark style="color:yellow;">**maxDepthAndUpdateDiamater**</mark>`()` use <mark style="color:red;">**recursion**</mark>
   * Termination condition: root = null, depth = 0ã€‚
   * <mark style="color:yellow;">**function 1**</mark>: calculate the current node's max depth by comparing the left subtree's max depth and right tree's max depth and return the max depth = leftMaxDepth + rightMaxDepth + 1&#x20;
     * use the logic of bottom up approach in DFS of the binary tree
   * <mark style="color:yellow;">**function 2:**</mark> update the max diameter by comparing it with the variable maxDiameterAcrossNode&#x20;
     * <mark style="color:red;">åœ¨è®¡ç®—æœ€å¤§</mark><mark style="color:red;">**depth**</mark><mark style="color:red;">çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿåœ¨æ¯ä¸ªrootå¤„è®¡ç®—</mark><mark style="color:red;">**diameter**</mark>ï¼ˆå³ï¼Œå·¦å­æ ‘çš„æœ€å¤§æ·±åº¦åŠ ä¸Šå³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼‰ï¼Œå¹¶<mark style="color:yellow;">**update**</mark>å…¨å±€å˜é‡ <mark style="color:yellow;">`maxDiameter`</mark>ï¼ˆå¦‚æœå½“å‰èŠ‚ç‚¹çš„diameterå¤§äº `diameter`ï¼‰ã€‚
3. in main function, call <mark style="color:yellow;">**maxDepthAndUpdateDiamater**</mark>ï¼Œreturn  `maxDiameter`ï¼Œ

<mark style="color:yellow;">**ä½•æ—¶æ›´æ–°diameter?**</mark>

æˆ‘ä»¬åœ¨è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦æ—¶ï¼Œéƒ½ä¼šæ›´æ–°ç›´å¾„ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬è®¡ç®—å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œç„¶åå°†è¿™ä¸¤ä¸ªå€¼ç›¸åŠ ï¼Œå¾—åˆ°çš„å°±æ˜¯é€šè¿‡å½“å‰èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ã€‚å¦‚æœè¿™ä¸ªè·¯å¾„æ¯”å½“å‰å·²çŸ¥çš„æœ€å¤§ç›´å¾„è¿˜è¦é•¿ï¼Œæˆ‘ä»¬å°±æ›´æ–° `diameter`ã€‚

</details>

<details>

<summary>Code Demo </summary>

{% code lineNumbers="true" %}
```java
class Solution {

    int maxDiameter = 0; // initiate to 0
    
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepthAndUpdateDiamater(root);
        return maxDiameter;
    }
    
    // Helper Method: 
    // 1. Computes the maximum depth of a binary tree rooted at the given node.
    //    Return the maxDepth of the given node
    // 2. Update the maxDiameter at each node with calculated left and right max depth
    private int maxDepthAndUpdateDiamater(TreeNode root) {
    
        if (root == null) { // Termination Condition
            return 0;
        }
        
        // 1. Bottom UP: Calculate the max depth of left and right node
        int leftMaxDepth = maxDepthAndUpdateDiamater(root.left);
        int rightMaxDepth = maxDepthAndUpdateDiamater(root.right);
        
        // 2. Update the maxDiameter at each node with leftMaxDepth, rightMaxDepth
        int maxDiameterAcrossNode = leftMaxDepth + rightMaxDepth;
        maxDiameter = Math.max(maxDiameter, maxDiameterAcrossNode);
        
        // 1. Bottom UP: Calculate the max depth of left and right node
        return Math.max(leftMaxDepth, rightMaxDepth) + 1;
    }
}
```
{% endcode %}

* `maxDepth()`å‡½æ•°æ˜¯ä½¿ç”¨è‡ªåº•å‘ä¸Šï¼ˆbottom-upï¼‰çš„æ–¹æ³•ã€‚è¿™æ˜¯å› ä¸ºå®ƒé¦–å…ˆé€’å½’åœ°è®¡ç®—å‡ºå·¦å­æ ‘å’Œå³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼ˆåŸºæœ¬æƒ…å†µæ˜¯å½“æ ‘ä¸ºç©ºæ—¶ï¼Œæ·±åº¦ä¸º0ï¼‰ï¼Œç„¶åè¿”å›å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ï¼ˆå·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦åŠ 1ï¼‰ã€‚
  * line 13-16, 18, 19, 26: éƒ½æ˜¯max Depthè®¡ç®—æ—¶å€™çš„method
* ç„¶è€Œï¼Œè®¡ç®—`maxDiameter`çš„è¿‡ç¨‹ä¸æ˜¯æ˜¯å…¸å‹çš„è‡ªé¡¶å‘ä¸‹ï¼ˆtop-downï¼‰æ–¹æ³•ï¼Œå› ä¸ºå®ƒå¹¶æ²¡æœ‰å…ˆä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œç„¶åé€’å½’åœ°åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šåº”ç”¨æŸç§æ“ä½œã€‚ç›¸åï¼Œ<mark style="color:yellow;">å®ƒæ˜¯åœ¨</mark><mark style="color:yellow;">`maxDepth`</mark><mark style="color:yellow;">å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œæ¯æ¬¡è®¡ç®—å‡ºä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦åï¼Œå°±ç«‹å³æ›´æ–°</mark><mark style="color:yellow;">`maxDiameter`</mark>ã€‚è¿™ç§æ–¹æ³•æ›´æ¥è¿‘äºè‡ªåº•å‘ä¸Šçš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒä¾èµ–äºä»ä¸‹åˆ°ä¸Šè®¡ç®—å‡ºçš„èŠ‚ç‚¹æ·±åº¦ä¿¡æ¯ã€‚
* æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è¯´è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸»è¦ä½¿ç”¨äº†è‡ªåº•å‘ä¸Šï¼ˆbottom-upï¼‰çš„æ–¹æ³•ã€‚å®ƒåœ¨è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ï¼ˆè‡ªåº•å‘ä¸Šï¼‰çš„åŒæ—¶ï¼Œä¹Ÿæ›´æ–°äº†æœ€å¤§ç›´å¾„ï¼ˆç›¸å½“äºå¦ä¸€ç§å½¢å¼çš„è‡ªåº•å‘ä¸Šï¼Œå› ä¸ºå®ƒä¾èµ–äºå·²ç»è®¡ç®—å‡ºçš„æ·±åº¦ä¿¡æ¯ï¼‰ã€‚

Recap:&#x20;

```java
// bottom up appoach to calculate the max depth
// used in the code
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMaxDepth = maxDepth(root.left);
        int rightMaxDepth = maxDepth(root.right);
        return Math.max(leftMaxDepth, rightMaxDepth) + 1;
    }
}
```

```java
// not used in the code
// top down for calcualting the maxDepth
// helper method: return void, ä¸¤ä¸ªparameter,éœ€è¦è€ƒè™‘ leaf node
class Solution {
    int maxDepth = 0; // initialize to 0

    public int maxDepth(TreeNode root) {
        calculateDepth(root, 1);
        return maxDepth;
    }

    // æ³¨æ„è¿™é‡Œcalculate depthæ— return value, ä½†æ˜¯æœ‰ä¸¤ä¸ªparams
    private void calculateDepth(TreeNode node, int depth) {
        // Termination Condition
        if (node == null) {
            return;
        }
        
        if (node.left == null && node.right == null) {
            maxDepth = Math.max(maxDepth, depth);
            return;
        }

        // Calculate the depth of left and right node
        calculateDepth(node.left, depth + 1);
        calculateDepth(node.right, depth + 1);
    }
}
```

```java
// top down: helper function return teh maxDepth 
// helper method: paramsåªæœ‰root, è€Œä¸”ä¸éœ€è¦è€ƒè™‘leaf node
// æ€æƒ³å’Œ543: calculate max diameter
class Solution {
    int maxDepth = 0; // initialize to 0

    public int maxDepth(TreeNode root) {
        return calculateDepth(root);
        
    }

    // æ³¨æ„è¿™é‡Œcalculate depthä¼šreturn value, è€Œä¸”ä¸ç”¨è€ƒè™‘leaf node
    private int calculateDepth(TreeNode node) {
        // Termination Condition
        if (node == null) {
            return 0;
        }

        // Calculate the depth of left and right node
        int leftDepth = calculateDepth(node.left);
        int rightDepth = calculateDepth(node.right);

        // Update the maxDepth at each node
        maxDepth = Math.max(maxDepth, Math.max(leftDepth, rightDepth) + 1);

        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

</details>

<details>

<summary>Code Analysis</summary>



</details>

<details>

<summary>å¿ƒå¾— Key Points</summary>



</details>
