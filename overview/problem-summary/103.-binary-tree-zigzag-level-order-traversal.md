# ğŸŸ  0103. Binary Tree Zigzag Level Order Traversal

<details>

<summary>Description é¢˜ç›®æè¿° </summary>

Given the `root` of a binary tree, return _the <mark style="color:yellow;">**zigzag level order traversal**</mark> of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).

```c
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9], // æ³¨æ„è¿™é‡Œä¸ä¸€æ ·
  [15,7]
]
```

![](<../../.gitbook/assets/image (1) (1) (1).png>)

</details>

<details>

<summary>è§£é¢˜æ€è·¯ Intuition </summary>

è™½ç„¶é¢˜ç›®æ˜¯level order traversalä½†æ˜¯ä¼¼ä¹æ›´é€‚åˆç”¨dfsçš„æ–¹æ³•æ¥è§£å†³ï¼Œå› ä¸ºbfséœ€è¦ç”¨åˆ°dequeueçš„æ–¹å¼ï¼Œä»¥åæœ‰ç©ºå¯ä»¥çœ‹çœ‹

</details>

<details>

<summary>âœ… Algorithm: DFS -> ç”¨ recursion&#x26;List, memory optimized ä¹Ÿå¥½ç†è§£</summary>

<img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt="" data-size="original">

* Initialize an empty result list (nested).
* Call a recursive helper function with the root and its level (1 for the root).
* In the helper function:
  * <mark style="color:red;">**If the level > resultListSize, add a new empty list to the result list.**</mark>
  * If the level is odd, add the node's value to the end of the list for this level in the result list. -- normal sequence
  * If the level is even, add the node's value to the beginning of the list for this level in the result list. -- backed sequence
  * Recurse on the left child then the right child with level + 1.
* Return the result list.

<mark style="color:yellow;">**æ³¨æ„ï¼š**</mark>

* è¿™é‡Œå¾ˆå®¹æ˜“å¡ List method:&#x20;
  * retrieve specific element with the index: <mark style="color:yellow;">**list.get(index)**</mark>
  * add element to a specific position: <mark style="color:yellow;">**list.add(0, value)**</mark>** **<mark style="color:red;">**=> add to front**</mark>
* ç”±äºæˆ‘æŠŠrootçš„levelè®¾ç½®æˆ1ï¼Œ æ‰€ä»¥åœ¨resultListçš„getæ—¶å€™çš„indexè¦-1
* ä½¿ç”¨äº†ç±»ä¼¼äº BFS çš„å¤„ç†æ–¹å¼ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨queueï¼Œè€Œæ˜¯é€šè¿‡é€’å½’å’Œåˆ—è¡¨æ¥å®ç°çš„ã€‚

<mark style="color:yellow;">**ç”¨dfsçš„å…³é”®ç‚¹**</mark><mark style="color:yellow;">ï¼š</mark>\
\- If the level > resultListSize, add a new empty list to the result list.æˆ‘ä»¬æ£€æŸ¥å½“å‰èŠ‚ç‚¹çš„å±‚çº§ `level` æ˜¯å¦å¤§äº `result` çš„å¤§å°ã€‚å¦‚æœæ˜¯ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬é¦–æ¬¡è®¿é—®åˆ°è¿™ä¸€å±‚ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨ `result` ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„ç©ºåˆ—è¡¨ã€‚<mark style="color:yellow;">å¦‚æœ</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`level`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">ç­‰äºæˆ–å°äº</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`result`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">çš„å¤§å°ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å·²ç»ä¸ºè¿™ä¸€å±‚åˆ›å»ºäº†ä¸€ä¸ªåˆ—è¡¨</mark>ï¼Œå› æ­¤æˆ‘ä»¬ä¸éœ€è¦å†åˆ›å»ºæ–°çš„åˆ—è¡¨ã€‚

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> resultList = new LinkedList<>();
        int rootLevel = 1; // here i initialize to 1
        
        zigzagBFS(root, rootLevel, resultList);
        return resultList;
    }
    
    private void zigzagBFS(TreeNode root, int currLevel, List<List<Integer>> resultList) {
        // termination condition
        if (root == null) {
            return;
        }
        // è¿™é‡Œæ˜¯dfsçš„å…³é”®
        if (currLevel > resultList.size()) {
            resultList.add(new LinkedList<>()); // åˆ›å»ºsublist
        }
        
        // å¤„ç†å½“å‰node
        // odd level: normal traversal, add the root value to the list end
        if (currLevel % 2 == 1) {
            resultList.get(currLevel - 1).add(root.val); // notice the index
        } else { // even level: add to the front
            resultList.get(currLevel - 1).add(0, root.val);
        } 
        
        // recursion on the left and right child to keep updating the resultList
        zigzagBFS(root.left, currLevel+1, resultList);
        zigzagBFS(root.right, currLevel+1, resultList);
    }
}
```

</details>

<details>

<summary>Algorithm: BFS -> use Dequeue structure, memory is less optimized å¥½ç†è§£</summary>

ä¸æƒ³çœ‹è¿™ä¸ªçš„åŸå›  the use of deque can be very useful in certain modifications of BFS. For example, in the zigzag level order traversal problem, where you need to traverse nodes from left to right at one level and then from right to left at the next level. In this case, you could use a deque and alternate between adding nodes to the front or back of the queue depending on the current level.

<mark style="color:yellow;">**BFS: Slightly change the algorithm**</mark>

1. Initialize a <mark style="color:yellow;">**double-ended queue**</mark> and add the root to it.
2. Initialize a boolean flag `leftToRight` to `true` to keep track of the direction for each level.
3. Start a while loop until the deque is empty:
   * For each level, get the size of the current level.
   * Initialize an empty list to store the nodes of the current level.
   * For each node in this level, if `leftToRight` is `true`, remove nodes from the front of the deque and add its value to the list, else remove nodes from the end of the deque and add its value to the list.
   * If the node has left or right children, add them to the deque. If `leftToRight` is `true`, add the left child first then the right child, else add the right child first then the left child.
   * After processing all nodes in the current level, add the list to the result list.
   * Toggle the `leftToRight` flag for the next level.
4. Return the result list.

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<List<Integer>>();
        }
        
        Deque<TreeNode> deque = new LinkedList<>();
        List<List<Integer>> results = new ArrayList<>();
        
        // Add the root to the deque.
        deque.add(root);
        // Initialize the direction.
        boolean leftToRight = true;
        
        while (!deque.isEmpty()) {
            // Number of elements in the current level.
            int levelNum = deque.size();
            // List to store nodes of the current level.
            List<Integer> levelList = new ArrayList<>();
            
            for (int i = 0; i < levelNum; i++) {
                if (leftToRight) {
                    // Remove nodes from the front of the deque.
                    TreeNode node = deque.pollFirst();
                    levelList.add(node.val);
                    // Add the left child then the right child.
                    if (node.left != null) {
                        deque.addLast(node.left);
                    }
                    if (node.right != null) {
                        deque.addLast(node.right);
                    }
                } else {
                    // Remove nodes from the end of the deque.
                    TreeNode node = deque.pollLast();
                    levelList.add(node.val);
                    // Add the right child then the left child.
                    if (node.right != null) {
                        deque.addFirst(node.right);
                    }
                    if (node.left != null) {
                        deque.addFirst(node.left);
                    }
                }
            }
            
            // Add the current level's list to the result list.
            results.add(levelList);
            // Flip the direction for the next level.
            leftToRight = !leftToRight;
        }
        
        return results;
    }
}
```

</details>

<details>

<summary>Code Analysis</summary>

Time Complexity: O(N)\
The time complexity of this zigzag traversal algorithm is O(N), where N is the number of nodes in the tree. This is because the algorithm traverses over all nodes of the tree exactly once.

Space Complexity: O(N)\
As for space complexity, in the worst case, if the tree is completely unbalanced, e.g., each node has only left child node, the recursion could go up to N levels deep, so the space complexity is O(N).

</details>

<details>

<summary>å¿ƒå¾— Key Points</summary>

ä¸ºä»€ä¹ˆè¦ç”¨DFS:\
è™½ç„¶ç¬¬ä¸€ä¸ªæˆ‘ä»¬ç”¨çš„æ˜¯ DFS çš„éå†æ–¹å¼ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶æŒ‰ç…§å±‚æ¬¡é¡ºåºæ¥å¤„ç†æ¯ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦åŒºåˆ†å‡ºæ¯ä¸€å±‚ï¼Œä»¥ä¾¿äºå®ç°é”¯é½¿å½¢çš„éå†é¡ºåºã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ç±»ä¼¼äº BFS çš„å¤„ç†æ–¹å¼ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨queueï¼Œè€Œæ˜¯é€šè¿‡é€’å½’å’Œåˆ—è¡¨æ¥å®ç°çš„ã€‚

bfséœ€è¦ç”¨åˆ°dequeueçš„æ–¹å¼ï¼Œä»¥åæœ‰ç©ºå¯ä»¥çœ‹çœ‹

</details>
