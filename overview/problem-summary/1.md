---
description: å®æ—¶æ›´æ–°max
---

# ğŸŸ  0662 - Maximum Width of Binary Tree

<details>

<summary>Description é¢˜ç›®æè¿° </summary>

Given the `root` of a binary tree, return _the **maximum width** of the given tree_.

The **maximum width** of a tree is the maximum **width** among all levels.

The **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.

It is **guaranteed** that the answer will in the range of a **32-bit** signed integer.

```
           1
         /   \
        3     2
       / \     \  
      5   3     9 

Output: 4
Explanation: third level with the length 4 (5,3,null,9).
```

```
          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation: fourth level with the length 8 (6,null,null,null,null,null,null,7)
```

<pre><code>          1
         / \
        3   2 
       /        
      5      
<strong>
</strong>Output: 2
Explanation: second level with the length 2 (3,2).
</code></pre>

```
          1
         /  
        3    
       / \       
      5   3     

Output: 2
Explanation: third level with the length 2 (5,3).
```

</details>

> The key to solve the problem though lie on <mark style="color:yellow;">**how we index the nodes that are on the same level.**</mark>  è¿™ä¸ªç´¢å¼•å°†æŒ‰ç…§complete binary treeçš„æ–¹å¼åˆ†é…ï¼Œå³rootçš„ç´¢å¼•ä¸º0ï¼Œleft subtreeçš„indexä¸º2_parentIndexï¼Œå³å­æ ‘çš„ç´¢å¼•ä¸º2_parentIndex+1ã€‚

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

<details>

<summary>è§£é¢˜æ€è·¯ Intuition </summary>

intuition: ç”¨level order traversal, å½¢æˆæ¯å±‚çš„ä¸€ä¸ªnested list&#x20;

</details>

<details>

<summary>Algorithm </summary>

<pre><code>æˆ‘ä»¬æŒ‰ç…§å®Œå…¨äºŒå‰æ ‘çš„æ–¹å¼ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ†é…ç´¢å¼•ã€‚
æ ¹èŠ‚ç‚¹çš„ç´¢å¼•ä¸º0ï¼Œå·¦å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º2parentIndexï¼Œå³å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º2parentIndex+1ã€‚
æ‰€ä»¥ï¼Œæ ‘çš„èŠ‚ç‚¹å’Œå…¶å¯¹åº”çš„ç´¢å¼•å¦‚ä¸‹ï¼š
    1(0)      [(1, 0)]
   /   \
 3(0)  2(1)   [(3, 0), (2, 1)]   -> é¦–éƒ¨ç´¢å¼•ï¼š0ï¼Œå°¾éƒ¨ç´¢å¼•ï¼š1ï¼Œå®½åº¦ï¼š1 - 0 + 1 = 2
 /
5(0)          [(5, 0)]   -> é¦–éƒ¨ç´¢å¼•ï¼š0ï¼Œå°¾éƒ¨ç´¢å¼•ï¼š0ï¼Œå®½åº¦ï¼š0 - 0 + 1 = 1
==========================================================================
    1(0)      [(1, 0)]
   /   \
 3(0)  2(1)   [(3, 0), (2, 1)]   -> <a data-footnote-ref href="#user-content-fn-1">ç´¢å¼•</a>ï¼š0ï¼Œå°¾éƒ¨ç´¢å¼•ï¼š1ï¼Œå®½åº¦ï¼š1 - 0 + 1 = 2
 / \     \
5(0) 3(1) 9(3)  [(5, 0), (3, 1), (9, 3)]   -> é¦–éƒ¨ç´¢å¼•ï¼š0ï¼Œå°¾éƒ¨ç´¢å¼•ï¼š3ï¼Œå®½åº¦ï¼š3 - 0 + 1 = 4
</code></pre>

ç®—æ³•æ­¥éª¤ï¼š

1. <mark style="color:orange;">**Initialization**</mark>\
   **-** Initialize ä¸€ä¸ªempty queueï¼Œenqueue  <mark style="color:blue;">**root.valåŠindex**</mark> as a <mark style="color:yellow;">**PAIR**</mark>\
   **-** Initialize a variable <mark style="color:yellow;">**maxWidth**</mark> to record the maximum width -- to be updated
2. <mark style="color:orange;">**Loop**</mark>: when the queue is not empty, process each level of the tree
   * <mark style="color:blue;">**Calculate Width**</mark>: Record the indices of the front and end nodes in the queue. \
     The width of this level is `endIndex - frontIndex + 1`.
   * <mark style="color:blue;">**Update Max Width**</mark>: If the calculated width is larger than `maxWidth`, update `maxWidth`.
   * <mark style="color:blue;">**Enqueue Children**</mark>: Traverse each node in the queue (i.e., all nodes at the current level), enqueue their children nodes with their corresponding indices. The index of the left child node is `2 * index`, and the index of the right child node is `2 * index + 1`.
3. è¿”å›æ‰€æœ‰å±‚ä¸­å®½åº¦æœ€å¤§çš„å€¼ã€‚

</details>

<details>

<summary>Code Demo : Using  a Pair to store the TreeNode and corresponding Index</summary>

This algorithm computes the maximum width of a binary tree using a <mark style="color:yellow;">**breadth-first search (BFS) approach**</mark>. Here are the steps:

1. <mark style="color:yellow;">**Initialization**</mark>
   1. Initialize an <mark style="color:blue;">**empty queu**</mark>e and add a <mark style="color:blue;">**pair of root and 0**</mark> to it. \
      This pair represents a node and its corresponding index at a given level.
   2. Initialize <mark style="color:blue;">**maxWidth**</mark> as `0`. This variable will <mark style="color:blue;">**keep track of the maximum width of the tree across all levels.**</mark>
2. <mark style="color:yellow;">**Loop**</mark>: Start a <mark style="color:blue;">**WHILE**</mark> loop that continues until the queue is empty. This loop will iterate level by level through the tree.
   1. For each level, record the <mark style="color:blue;">**size**</mark> of the queue, which represents the total number of nodes at this level.
   2. Initialize `left` and `right` variables as `-1`. These variables will hold the indices of the leftmost and rightmost nodes at each level.
   3. Start a <mark style="color:yellow;">**FOR loop**</mark> that iterates `size` times. This loop will process all nodes at the current level.
      1. For each node at the current level, remove the node from the queue and get its index.
      2. If the node is the first at its level (`i == 0`), record its index in `left`. If the node is the last at its level (`i == size - 1`), record its index in `right`.
      3. If the current node has a left child, add a pair of the left child and its corresponding index (`2 * index`) to the queue. If the current node has a right child, add a pair of the right child and its corresponding index (`2 * index + 1`) to the queue.
      4. After processing all nodes at the current level, calculate the width of this level as `right - left + 1`, and update `maxWidth` if the current level's width is greater than `maxWidth`.
3. Finally, return `maxWidth` as the maximum width of the binary tree.

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
     // ========= Initialization ============
        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();
        queue.offer(new Pair<>(root, 0));
        int maxWidth = 0;
      
     // ============== Loop ==================
        while (!queue.isEmpty()) {
        
            int size = queue.size();
            int left = -1, right = -1;

            for (int i = 0; i < size; i++) {
                Pair<TreeNode, Integer> pair = queue.poll();
                TreeNode node = pair.getKey();
                int index = pair.getValue();
                
                // check
                if (i == 0) left = index;
                if (i == size - 1) right = index;
                // update queue: check left and right 
                if (node.left != null) {
                    queue.offer(new Pair<>(node.left, 2 * index));
                }
                if (node.right != null) {
                    queue.offer(new Pair<>(node.right, 2 * index + 1));
                }
            }

            maxWidth = Math.max(maxWidth, right - left + 1);
        }

        return maxWidth;
    }
}
```

</details>

<details>

<summary>Code Demo: same algorithm but use <mark style="color:yellow;">TWO QUEUES(linked list)</mark> to store the treenode and index separately => improve runtime</summary>

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        // ========= Initialization ============
        // Initialization: two empty queue
        Queue<TreeNode> nodeQueue = new LinkedList<>(); // store each node to get the size
        Queue<Integer> indexQueue = new LinkedList<>(); // store each node's level index
        nodeQueue.offer(root);
        indexQueue.offer(0);
        // Initialization: maxWidth = 0 => to be updated
        int maxWidth = 0;
        
        // ============== Loop ==================
        while (!nodeQueue.isEmpty()) {
            int levelSize = nodeQueue.size(); // get the size of iteration
            int frontIndex = -1;
            int endIndex = -1; 

            // start level iteration using FOR lop
            for (int i = 0; i < levelSize; i++) {
                
                TreeNode currNode = nodeQueue.poll();
                int currIndex = indexQueue.poll();

                // check if the index is the front/end index
                if (i == 0) frontIndex = currIndex; // if it is, update the level frontIndex
                if (i == levelSize - 1) endIndex = currIndex; // and endIndex
                
                // check if the currNode have left/right child 
                if (currNode.left != null) {
                    nodeQueue.add(currNode.left);
                    indexQueue.add(currIndex*2);
                } 
                if (currNode.right != null) {
                    nodeQueue.add(currNode.right);
                    indexQueue.add(currIndex*2 + 1);
                }
            }
            // after each level traversal, update the maxWidth
            maxWidth = Math.max(maxWidth, (endIndex - frontIndex + 1));
        }
        return maxWidth;
    }
    
}
```

</details>

<details>

<summary>Code Analysis</summary>

Time Complexity:

The time complexity of this algorithm is O(N), where N is the total number of nodes in the tree. This is because the algorithm processes each node exactly once.

Space Complexity:

The space complexity of this algorithm is O(N), where N is the total number of nodes in the tree. This is because in the worst case, the queue might need to store all the leaf nodes at the deepest level. In a complete binary tree, the deepest level could have N/2 nodes, so the space complexity is O(N).

</details>

<details>

<summary>âœ… å¿ƒå¾— Key Points</summary>

* å®³ ç”¨<mark style="color:yellow;">**bfsçš„è·¯å¾„**</mark>ä¸ç†Ÿæ‚‰ï¼Œç”¨queueçš„while + for loop ä¸èƒ½æ€•
* è¿˜æœ‰ä¸€ä¸ªæ˜¯è¦ä¸€ç›´updateä¸€ä¸ªmaxWidthçš„value,
* è¿™é“é¢˜mediumçš„ç‚¹åœ¨äºå¯¹æ¯ä¸ª<mark style="color:yellow;">**levelçš„nodeçš„indexçš„æ ‡è®°**</mark>ï¼Œè¿™ä¸ªæ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°
  * ä»¥åŠ<mark style="color:red;">**root index**</mark> = 0, <mark style="color:red;">**left child**</mark> = 2\*ParentIndex, <mark style="color:red;">**right child**</mark> = 2\*ParentIndex + 1
  * ä»¥åŠ<mark style="color:red;">**width**</mark>çš„ç†è§£ <mark style="color:blue;">**rightIndex - leftIndex + 1**</mark>
* ç”¨åˆ°äº†<mark style="color:yellow;">**Pair**</mark>ï¼Œå¯¹äºpairæ¥è®²javaæœ‰build in çš„classï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨ï¼Œä½†æ˜¯initiliaztionä¹‹ç±»çš„å¾ˆå®¹æ˜“å‡ºé”™
* ä¹Ÿå¯ä»¥ä¸ç”¨pairï¼Œå»ºç«‹ä¸¤ä¸ªqueue: linked list
* gpt4è¿˜è¯´ç”¨ArrayDequeuæ¥å‚¨å­˜queueï¼Œç®—äº†å§

</details>

<details>

<summary>å°æ’æ›² ç”¨ArrayDeque</summary>

`ArrayDeque` is a class in Java that provides a way to apply resizable-array and implements the `Deque` interface. It is also known as "Array Double Ended Queue" because it can add or remove elements from both ends.

`ArrayDeque` is faster than `Stack` when used as a stack, and faster than `LinkedList` when used as a queue. Most `ArrayDeque` operations run in amortized constant time.

Here are some important points about `ArrayDeque`:

1. It does not have capacity restrictions; it grows as necessary to support operations.
2. `null` elements are prohibited in the `ArrayDeque`.
3. They are not thread-safe; in the absence of external synchronization, `ArrayDeque` does not support concurrent access by multiple threads.
4. This class is likely to be faster than `Stack` when used as a stack, and faster than `LinkedList` when used as a queue.

Here is a simple example of how to use `ArrayDeque`:

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();

        // Add elements.
        deque.add("Element 1 (Tail)");
        deque.addFirst("Element 2 (Head)");
        deque.addLast("Element 3 (Tail)");
        deque.push("Element 4 (Head)"); // Adds to the head
        deque.offer("Element 5 (Tail)");
        deque.offerFirst("Element 6 (Head)");
        deque.offerLast("Element 7 (Tail)");

        // Iterate through the deque elements.
        for (String element : deque) {
            System.out.println("Element : " + element);
        }

        // Remove elements.
        deque.removeFirst();
        deque.removeLast();
        deque.pop();

        System.out.println("Deque after removing elements: " + deque);
    }
}
```

This code shows how to add elements to the head and tail of an `ArrayDeque`, iterate over its elements, and remove elements from the head and tail.\


```java
import java.util.*;

class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        Deque<TreeNode> nodeQueue = new ArrayDeque<>();
        Deque<Integer> indexQueue = new ArrayDeque<>();
        nodeQueue.offer(root);
        indexQueue.offer(0);
        int maxWidth = 0;

        while (!nodeQueue.isEmpty()) {
            int size = nodeQueue.size();
            int left = -1, right = -1;

            for (int i = 0; i < size; i++) {
                TreeNode node = nodeQueue.poll();
                int index = indexQueue.poll();

                if (i == 0) left = index;
                if (i == size - 1) right = index;

                if (node.left != null) {
                    nodeQueue.offer(node.left);
                    indexQueue.offer(2 * index);
                }
                if (node.right != null) {
                    nodeQueue.offer(node.right);
                    indexQueue.offer(2 * index + 1);
                }
            }

            maxWidth = Math.max(maxWidth, right - left + 1);
        }

        return maxWidth;
    }
}
```

</details>



[^1]: 
